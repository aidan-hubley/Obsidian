#DatabseConcepts [[2. How to normalize a data structure]]
- Databases are often designed by database administrators (DBAs) or design specialists. This is especially true for large, multiuser databases. How well this is done can directly affect your job as a MySQL programmer. In general, a well-designed database is easy to understand and query, while a poorly designed database is difficult to work with. In fact, when you work with a poorly designed database, you will often need to figure out how it is designed before you can code your queries appropriately. The topics that follow present a basic approach for designing a data structure. We use that term to refer to a model of the database rather than the database itself. Once you design the data structure, you can use the techniques presented in the next two chapters to create a database with that design. By unde1Â·standing the right way to design a database, you'll work more effectively as a MySQL programmer.

## The basic steps for designing a data structure
- In many cases, you can design a data structure based on an existing real-world system. The illustration at the top of figure 10-1 presents a conceptual view of how this works. Here, you can see that all of the information about the people, documents, and facilities within a real-world system is mapped to the tables, columns, and rows of a database system. As you design a data structure, each table represents one object, or entity, in the real-world system. Then, within each table, each column stores one item of information, or attribute, for the entity, and each row stores one occurrence, or instance, of the entity. This figure also presents the six steps you can follow to design a data structure. You'll learn more about each of these steps in the topics that follow. In general, though, step 1 is to identify all the data elements that need to be stored in the database. Step 2 is to break complex elements down into smaller components whenever that makes sense. Step 3 is to identify the tables that will make up the system and to determine which data elements are assigned as columns in each table. Step 4 is to define the relationships between the tables by identifying the primary and foreign keys. Step 5 is to normalize the database to reduce data redt1ndancy. And step 6 is to identify the indexes that are needed for each table. To model a database system after a real-world system, you can use a technique called entity-relationship (ER) modeling. Because this is a complex subject of its own, I won't present it in this book. However, I have applied some of the basic elements of this technique to the design diagrams presented in this chapter. In effect, then, you'll be learning so1ne of the basics of this modeling technique.
### A database system is modeled after a real-world system
![[Pasted image 20221025163805.png]]
### The six basic steps for designing a data structure
1. Step 1: Identify the data elements
2. Step 2: Subdivide each element into its smallest useful components
3. Step 3: Identify the tables and assign column
4. Step 4: Identify the primary and foreign keys
5. Step 5: Review whether the data structures is normalized
6. Identify the indexes
### Description
- A relational database system should model the real-world environment where it's used. The job of the designer is to analyze the real-world system and then map it onto a relational database system. 
- A table in a relational database typically represents an object, or entity, in the real world. Each column of a table is used to store an attribute associated with the entity, and each row represents one instance of the entity. 
- To model a database and the relationships between its tables after a real-world system, you can use a technique called entity-relationship (ER) modeling. Some of the diagrams you'll see in this chapter apply the basic elements of ER modeling.

## How to identify the data elements
- The first step for designing a data structure is to identify the data elements required by the system. You can use several techniques to do that, including analyzing the existing system if there is one, evaluating comparable systems, and interviewing anyone who will be using the system. One particularly good source of information is the documents used by an existing system. 
- In figure 10-2, for example, you can see an invoice that's used by an accounts payable system. We'll use this document as the main source of information for the database design presented in this chapter. Keep in mind, though, that you'll want to use all available resources when you design your own database. 
- If you study this document, you'll notice that it contains information about three different entities: vendors, invoices, and line items. First, the form itself has preprinted info1mation about the vendor who issued the invoice, such as the vendor's name and address. If this vendor were to issue another invoice, this information wouldn't change. 
- This document also contains specific information about the invoice. Some of this information, such as the invoice number, invoice date, and invoice total, is general in nature. Although the actL1al information will vary from one invoice to the next, each invoice will include this information. In addition to this general information, each invoice includes information about the items that were purchased. Although each line item contains similar information, each invoice can contain a different number of line items. 
- One of the things you need to consider as you review a document like this is how much information your system needs to track. For an accounts payable system , for example, you may not need to store detailed data such as the information about each line item. Instead, you may just need to store summary data like the invoice total. As you think about what data elements to include in the database, then, you should have an idea of what information you'll need to get back out of the system.
### An invoice that can be used to identify data elements
![[Pasted image 20221025164435.png]]
### The data elements identified on the invoice document
![[Pasted image 20221025164506.png]]
### Description
- Depending on the nature of the system, you can identify data elements in a variety of ways, including interviewing users, analyzing existing systems, and evaluating comparable systems. 
- The documents used by a real-world system, such as the invoice shown above, can often help you identify the data elements of the system. 
- As you identify the data elements of a system, you should begin thinking about the entities that those elements are associated with. That will help you identify the tables of the database later on.

## How to subdivide the data elements
- Some of the data elements you identify in step 1 of the design procedt1re will consist of multiple components. The next step, then, is to divide these elements into their smallest useful values. Figure 10-3 shows how you can do that. 
- The first example in this figure shows how you can divide the name of the sales contact for a vendor. Here, the name is divided into two elements: a first name and a last name. When you divide a name like this, you can easily perform operations like sorting by last name and using the first name in a salutation, such as ''Dear Ruben." In contrast, if the full name is stored in a single column, you have to use the string functions to extract the component you need. But as you learned in the last chapter, that can lead to inefficient and complicated code. In general, then, you should separate a name like this whenever you'll need to use the name components separately. Later, when you need to use the full name, you can concatenate the first and last names. 
- The second example shows how you typically divide an address. Notice in this example that the street number and street name are stored in a single column. Although you could store these components in separate columns, that usually doesn't make sense since these values are typically used together. That's what I mean when I say that the data elements should be divided into their smallest useful values. 
- With that guideline in mind, you 1night even need to divide a single string into two or more components. A bulk mail system, for example, might require a separate column for the first three digits of the zip code. And a telephone number could require as many as four columns: one for the area code, one for the three-digit prefix, one for the four-digit number, and one for the extension. 
- As in the previous step, knowledge of the real-world system and of the information that will be extracted from the database is critical. In some circumstances, it may be okay to store data elements with multiple components in a single column. That can simplify your design and reduce the overall number of columns. In general, though, most designers divide data elements as much as possible. That way, it's easy to accommodate almost any query, and you don't have to change the database design later on when you realize that you need to use just part of a column value.
### A name that's divided into first and last names
![[Pasted image 20221025170152.png]]
### An address that's divided into street address, city, state, and zip code
![[Pasted image 20221025170216.png]]
### Description
- If a data element contains two or more components, you should consider subdividing the element into those components. That way, you won't need to parse the element each time you use it. 
- The extent to which you subdivide a data element depends on how it will be used. Because it's difficult to predict all future uses for the data, most designers subdivide data elements as much as possible. 
- When you subdivide a data ele1nent, you can easily rebuild it when necessary by concatenating the individt1al components.

## How to identify the tables and assign columns
- Figure 10-4 presents the three main entities for the accounts payable system and lists the possible data elements that can be associated with each one. In most cases, you'll recognize the main entities that need to be included in a data structure as you identify the data elements. As I reviewed the data elements represented on the invoice document in figure 10-2, for example, I identified the three entities shown in this figure: vendors, invoices, and invoice line items. Although you may identify additional entities later on in the design process, it's sufficient to identity the main entities at this point. These entities will become the tables of the database. 
- After you identify the main entities, you need to determine which data elements are associated with each entity. These elements will become the columns of the tables. In many cases, the associations are obvious. For example, it's easy to determine that the vendor name and address are associated with the vendors entity and the invoice date and invoice total are associated with the invoices entity. Some associations, however, aren't so obvious. In that case, you may need to list a data element under two or more entities. In this figure, for example, you can see that the invoice number is included in both the invoices and invoice line items entities and the account number is included in all three entities. Later, when you normalize the data structure, you may be able to remove these repeated elements. For now, though, it's okay to include them. 
- Before I go on, I want to point out the notation I used in this figure. To start, any data elements I included that weren't identified in previous steps are shown in italics. Although you should be able to identify most of the data elements in the first two steps of the design process, you'll occasionally think of additional elements during the third step. In this case, since the initial list of data elements was based on a single document, I added several data elements to this list. 
- Similarly, you may decide during this step that you don't need some of the data elements you've identified. For example, I decided that I didn't need the fax number or web address of each vendor. So I used the strikethrough feature of my word processor to indicate that these data elements should not be included. 
- Finally, I identified the data elements that are included in two or more tables by coding an asterisk after them. Although you can use any notation you like for this step of the design process, you'll want to be sure that you document your design decisions. For a complicated. design, you will probably want to use a CASE ( computer-aided software engineering) tool. 
- By the way, a couple of the new data elements I added may not be clear to you if you haven't worked with a corporate accounts payable system before. ''Terms'' refers to the payment terms that the ve11dor offers. For example, the terms might be net 30 (the invoice must be paid in 30 days) or might include a discount for early payment. ''Account number'' refers to tl1e general ledger accounts that a company uses to track its expenses. For example, one account number might be assigned for advertising expenses, while another might be for office supplies. Each invoice that's paid is assigned to an account, and in some cases, different line items on an invoice are assigned to different accounts.
### Possible tables and columns for an account payable system
![[Pasted image 20221025172032.png]]
### Description
- After you identify and subdivide all of the data elements for a database, you should group them by the entities with which they're associated. These entities will later become the tables of the database, and the elements will become the columns. 
- If a data element relates to more than one entity, you can include it under all of the entities it relates to. Then, when you normalize the database, you may be able to remove the duplicate elements. 
- As you assign the elements to entities, you should omit elements that aren't needed, and you should add any additional elements that are needed. 
### The notation used in this figure 
- Data elements that were previously identified but aren't needed are crossed out. 
- Data elements that were added are displayed in italics. â¢ Data elements that are related to two or more entities are followed by an asterisk. 
- You can use a similar notation or develop one of your own. You can also use a CASE ( computer-aided software engineering) tool if one is available to you.

## How to identify the primary and foreign key
- Once you identify the entities and data elements of a system, the next step is to identify the relationships between the tables. To do that, you need to identify the primary and foreign keys as shown in figure 10-5. 
- As you know, a primary key is used to uniquely identify each row in a table. In some cases, you can use an existing column as the primary key. For example, you might consider using the vendor_name column as the primary key of the Vendors table. Because the values for this column can be long, however, and because it would be easy to enter a value like that incorrectly, that's not a good candidate for a primary key. Instead, you should use an ID column like vendor_id that's incremented by one for each new row. 
- Similarly, you 1night consider using the invoice_number column as the primary key of the Invoices table. However, it's possible for different vendors to use the same invoice number, so this value isn't necessarily unique. Because of that, another ID column like invoice_id can be used as the primary key. 
- To uniquely identify the rows in the Invoice_Line_Items table, this design uses a composite key. This composite key uses two columns to identify each row. The first column is the invoice_id column from the Invoices table, and the second column is the invoice_sequence column. This is necessary because this table may contain more than one row (line item) for each invoice. And that means that the invoice_id value by itself may not be unique. 
- After you identify the primary key of each table, you need to identify the relationships between the tables and add foreign key columns as necessary. In most cases, two tables will have a one-to-many relationship with each other. For example, each vendor can have many invoices, and each invoice can have many line items. To identify the vendor that each invoice is associated with, a vendor_id column is included in the Invoices table. Because the Invoice_Line_Items table already contains an invoice_id column, it's not necessary to add another column to this table. 
- The diagram at the top of this figure illustrates the relationships I identified between the tables in the accounts payable system. As you can see, the primary keys are displayed in bold. Then, the lines between the tables indicate how the primary key in one table is related to the foreign key in another table. Here, a small, round connector indicates the ''one'' side of the relationship, and the triangular connector indicates the ''many'' side of the relationship. 
- In addition to the one-to-many relationships shown in this diagram, you can also use many-to-many relationships and one-to-one relationships. The second diagram in this figure, for example, shows a many-to-many relationship between an Employees table and a Committees table. As you can see, this type of relationship can be implemented by creating a linking table, also called a connecting table or an associate table. This table contains the primary key columns from the two tables. Then, each table has a one-to-many relationship with the linking table. Notice that the linking table doesn't have its own primary key. Because this table doesn't correspond to an entity and because it's used only in conjunction with the Employees and Committees tables, a primary key isn't needed.
### The relationship between the tables in the accounts payable system
![[Pasted image 20221025172516.png]]
### Two tables with a many-to-many relationship
![[Pasted image 20221025172543.png]]
### Two tables with a one-to-one relationship
![[Pasted image 20221025172603.png]]
### Description
- Each table should have a primary key that uniquely identifies each row. If possible, you should use an existing column for the primary key. 
- The values of the primary keys should seldom, if ever, change. The values should also be short and easy to enter correctly. 
- If a suitable column doesn't exist for a p1imary key, you can create an ID column that is incremented by one for each new row as the primary key. 
- If two tables have a one-to-many relationship, you may need to add a foreign key column to the table on the ''many'' side. The foreign key column must have the same data type as the primary key column it's related to. 
- If two tables have a many-to-many relationship, you'll need to define a linking table to relate them. Then, each of the tables in the many-to-many relationship will have a one-to-many relationship with the linking table. The linking table doesn't usually have a primary key. 
- If two tables have a one-to-one relationship, they should be related by their primary keys. This type of relationship is typically used to improve performance. Then, columns with large amounts of data can be stored in a separate table.
- The third example in figure 10-5 illustrates two tables that have a one-to-one relationship. With this type of relationship, both tables have the same primary key, which 1neans that the information could be stored in a single table. This type of relationship is often used when a table contains one or more columns with large amounts of data. In this case, the Employee_Photos table contains a large binary column with a photo of each employee. Because this column is used infrequently, storing it in a separate table will make operations on the Employees table more efficient. Then, when this column is needed, it can be combined with the columns in the Employees table using a join.

## How to enforce the relationship between tables
- Although the primary keys and foreign keys indicate how the tables in a database are related, the database management system doesn't always enforce those relationships automatically. In that case, any of the operations shown in the table at the top of figure 10-6 would violate the referential integrity of the tables. If you deleted a row from a primary key table, for example, and the foreign key table included rows related to that primary key, the referential integrity of the two tables would be destroyed. In that case, the rows in the foreign key table that no longer have a related row in the primary key table would be orphaned. Similar problems can occur when you insert a row into the foreign key table or update a pri1nary key or foreign key value. 
- To enforce those relationships and maintain the referential integrity of the tables, MySQL provides for declarative referential integrity. To use it, you define foreign key constraints that indicate how the referential integrity between the tables is enforced. You'll learn more about defining foreign key constraints in the next chapter. For now, just realize that these constraints can prevent all of the operations listed in this figure that violate referential integrity.
### Operations that can violate referential integrity
![[Pasted image 20221025172746.png]]
### Description
- Referential integrity means that the relationships between tables are maintained correctly. That means that a table with a foreign key doesn't have rows with foreign key values that don't have matching primary key values in the related table. 
- In MySQL, you can enforce referential integrity by using declarative referential integrity. 
- To use declarative referential integrity (DRI), you define foreign key constraints. You'll learn how to do that in the next chapter. 
- When you define foreign key constraints, you can specify how referential integrity is enforced when a row is deleted from the primary key table. The options are to return an error, to delete the related rows in the foreign key table, or to set the foreign key values in the related rows to null. 
- If referential integrity isn't enforced and a row is deleted from the primary key table that has related rows in the foreign key table, the rows in the foreign key table are said to be orphaned
## How normalization works
- The next step in the design process is to review whether the data structure is normalized. To do that, you look at how the data is separated into related tables. If you follow the first four steps for designing a database that are presented in this chapter, your database will already be partially normalized when you get to this step. However, almost every design can be normalized further. 
- Figure 10-7 illustrates how normalization works. The first two tables in this figure show some of the problems caused by an unnormalized data structure. In the first table, you can see that each row represents an invoice. Because an invoice can have one or more line items, however, the item_description column must be repeated to provide for the maximum number of line items. But since most invoices have fewer line items than the maximum, this can waste storage space. 
- In the second table, each line item is stored in a separate row. That eliminates the problem caused by repeating the item_description column, but it introduces a new problem: the vendor name and invoice number must be repeated in each row. This, too, can cause storage problems, particularly if a repeated column is large. In addition, it can cause maintenance problems if a column contains a value that's likely to change. Then, when the value changes, each row that contains the value must be updated. And if a repeated value n1ust be reentered for each new row, it would be easy for the value to vary from one row to another. 
- To eliminate the problems cat1sed by data redundancy, you can normalize the data structure. To do that, you apply the normal forms you'll learn about later in this chapter. As you'll see, there are a total of seven normal forms. However, it's common to apply only the first three. The diagram in this figure, for example, shows the accounts payable system in third normal form. Although it may not be obvious at this point how this reduces data redundancy, that will become clearer as you learn about the different normal forms.
### A table that contains repeating columns
![[Pasted image 20221025172912.png]]
### A table that contains redundant data
![[Pasted image 20221025172929.png]]
### The accounts payable system in third normal form
![[Pasted image 20221025172952.png]]
### Description
- Normalization is a formal process you can use to separate the data in a data structure into related tables. Normalization reduces data redundancy, which can cause storage and maintenance problems.
- In an unnormalized data structure, a table can contain information about two or more entities. It can also contain repeating columns, columns that contain repeating values, and data that's repeated in two or more rows. 
- In a normalized data structure, each table contains information about a single entity, and each piece of information is stored in exactly one place. 
- To normalize a data structure, you apply the normal forms in sequence. Although there are a total of seven normal forms, a data structure is typically considered normalized if the first three normal forms are applied. 

## How to identify the columns to be indexed
- The last step in the design process is to identify the columns that should be indexed. An index is a structure that provides for locating one or more rows directly. Without an index, a database management system has to perform a table scan, which involves searching through the entire table. 
- Just as the index of a book has page numbers that direct you to a specific subject, a database index has pointers that direct the system to a specific row. This can speed performance not only when you're searching for rows based on a search condition, but also when you're joining data from tables. If a join is done based on a primary key to foreign key relationship, for example, and an index is defined for the foreign key column, the database management system can use that index to locate the rows for each primary key value. 
- When you use MySQL, an index is automatically created for the primary and foreign keys in each table that you create. But you should consider creating indexes for other columns in some of the tables based on the guidelines at the top of figure 10-8. 
- To start, you should index a column if it will be used frequently in search conditions or joins. The column should also contain mostly distinct values, and the values in the column should be updated infrequently. If these conditions aren't met, the overhead of maintaining the index will probably outweigh the advantages of using it. 
- When you create indexes, you should be aware that MySQL must update the indexes whenever you add, update, or delete rows. Because that can affect performance, you don't want to define more indexes than you need. 
- As you identify the indexes for a table, keep in mind that, like a key, an index can consist of two or more columns. This type of index is called a composite index.
### When to create an index
- When the column is used frequently in search conditions or joins
- When the column contains a large number of distinct values
- When the column is updated frequently
### Description
- MySQL automatically creates an index for primary and foreign keys. 
- An index provides a way for a database management system to locate information more quickly. When it uses an index, the database management system can go directly to a specific row rather than having to search through all the rows until it finds it. 
- Indexes speed performance when searching and joining tables. 
- You can create composite indexes that include two or more columns. You should use this type of index when the columns in the index are updated infrequently or when the index covers almost every search condition on the table. 
